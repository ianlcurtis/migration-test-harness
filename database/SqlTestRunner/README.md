# SQL Test Runner

A C# .NET console application for executing comprehensive stored procedure tests generated by the SQL Test Framework prompt.

## Features

- **CSV Test Case Loading**: Reads test arguments from CSV files
- **SQL Setup Execution**: Automatically sets up test data from SQL scripts
- **Database Cleanup**: Purges database between tests for isolation
- **Comprehensive Output Capture**: Captures all stored procedure outputs
  - Return values
  - Output parameters
  - Result sets (all rows and columns)
- **Database State Verification**: Captures and logs database state after each test
  - Auto-detects tables affected by stored procedure
  - Custom verification queries per test
  - Specific table capture configuration
- **Multiple Output Formats**: Generates CSV, JSON, and HTML reports with full details
- **Flexible Configuration**: Command-line arguments and JSON configuration
- **Comprehensive Logging**: Detailed execution logging with configurable levels
- **Test Filtering**: Run specific tests by ID or category
- **Error Handling**: Graceful error handling with detailed reporting

## Quick Start

1. **Build the application:**
   ```bash
   dotnet build
   ```

2. **Configure your settings in `appsettings.json`:**
   ```json
   {
     "TestConfiguration": {
       "ConnectionString": "Server=localhost;Database=YourDB;Trusted_Connection=true;",
       "StoredProcedureName": "YourStoredProcedure"
     }
   }
   ```

3. **Run all tests:**
   ```bash
   dotnet run
   ```

## Command Line Usage

### Basic Usage
```bash
# Run with default configuration
dotnet run

# Specify connection string
dotnet run --connection-string "Server=localhost;Database=TestDB;Trusted_Connection=true;"

# Run specific tests
dotnet run --test-ids T001 T002 T003

# Run tests by category
dotnet run --categories HAPPY_PATH EDGE_CASE

# Enable verbose logging
dotnet run --verbose
```

### Complete Command Line Options
```bash
dotnet run [options]

Options:
  --config <file>              Configuration file path
  --connection-string <string> Database connection string
  --csv-file <file>           Test arguments CSV file path
  --sql-file <file>           Test data setup SQL file path
  --cleanup-file <file>       Database cleanup SQL file path
  --stored-procedure <name>   Stored procedure name to test
  --output <directory>        Output directory for results
  --test-ids <ids>            Comma-separated test IDs to run
  --categories <categories>   Test categories to run (HAPPY_PATH, UNHAPPY_PATH, EDGE_CASE)
  --stop-on-failure          Stop on first test failure
  --verbose                  Enable verbose logging
```

## Configuration

### appsettings.json Structure
```json
{
  "TestConfiguration": {
    "ConnectionString": "connection string here",
    "TestArgumentsCsvPath": "./test_data/test_arguments.csv",
    "TestDataSetupSqlPath": "./test_data/test_data_setup.sql",
    "CleanupSqlPath": "./test_data/cleanup_database.sql",
    "StoredProcedureName": "YourStoredProcedureName",
    "TestResultsOutputPath": "./test_results/test_results",
    "StopOnFirstFailure": false,
    "CommandTimeoutSeconds": 30,
    "CleanupBetweenTests": true,
    "TestIdsToRun": [],
    "CategoriesToRun": []
  },
  "DatabaseConfiguration": {
    "Server": "localhost",
    "Database": "YourDatabaseName",
    "TrustedConnection": true,
    "ConnectionTimeout": 30,
    "Encrypt": true,
    "TrustServerCertificate": false
  }
}
```

## File Structure Requirements

Your test files should follow this structure:
```
your-project/
├── test_data/
│   ├── test_arguments.csv      # Test cases and parameters
│   ├── test_data_setup.sql     # Database setup for each test
│   └── cleanup_database.sql    # Database cleanup script
├── SqlTestRunner/
│   ├── SqlTestRunner.csproj
│   ├── appsettings.json
│   └── Program.cs
└── test_results/               # Generated reports
    ├── test_results.csv
    ├── test_results.json
    └── test_results.html
```

## Test Case CSV Format

The CSV file must contain these required columns:
- `test_id`: Unique test identifier (T001, T002, etc.)
- `test_name`: Descriptive test name
- `test_category`: HAPPY_PATH, UNHAPPY_PATH, or EDGE_CASE
- `description`: Detailed test description
- `expected_result`: Expected outcome (SUCCESS, ERROR, or specific value)
- `expected_error_message`: Expected error text (if applicable)
- `setup_note`: Notes about test setup requirements

Additional columns represent stored procedure parameters.

## SQL Setup File Format

The SQL file should contain sections for each test with optional verification queries:

```sql
-- TEST: T001 - Test Name
-- Category: HAPPY_PATH
-- Description: Test description
-- Expected: Expected outcome
INSERT INTO Users (user_id, username) VALUES (1001, 'test_user');
INSERT INTO Products (product_id, name) VALUES (501, 'test_product');

-- VERIFY: T001
-- QUERY: UserBalance
SELECT user_id, username, balance FROM Users WHERE user_id = 1001;
-- QUERY: ProductStatus
SELECT product_id, name, status FROM Products WHERE product_id = 501;

-- TEST: T002 - Another Test
-- Category: UNHAPPY_PATH
-- Description: Another test description
-- Expected: Another expected outcome
INSERT INTO Users (user_id, username) VALUES (1002, 'test_user_2');
```

### Verification Queries (Optional)

Add `-- VERIFY: [TestId]` sections to define custom SQL queries that capture database state after test execution:

- Each query should be prefixed with `-- QUERY: [QueryName]`
- Query names will appear in the output reports
- Queries are executed immediately after the stored procedure
- Results are captured and included in all report formats

If no verification queries are provided, the application will auto-detect tables affected by the stored procedure and capture their state.

## Stored Procedure Output Capture

The test runner automatically captures:

### 1. **Return Value**
- The integer return value from the stored procedure
- Displayed in reports as `ReturnValue`

### 2. **Output Parameters**
- All parameters marked with `OUTPUT` or `INOUT`
- Parameter names and values captured
- Available in JSON and HTML reports

### 3. **Result Sets**
- All SELECT statement results from the stored procedure
- Multiple result sets supported
- Full row and column data captured
- Displayed in expandable sections in HTML report

### 4. **Database State**
- Tables affected by the stored procedure
- Custom verification query results
- Captured immediately after procedure execution
- Three capture modes:
  - **Custom Queries**: Use `-- VERIFY:` sections in SQL setup file
  - **Specific Tables**: Configure `TablesToCapture` in settings
  - **Auto-Detect**: Automatically detect and capture affected tables

## Output Reports

The application generates three types of reports with comprehensive details:

### 1. CSV Report (`test_results.csv`)
- Comma-separated values for data analysis
- Contains test execution details including:
  - Return values
  - Output parameter counts
  - Result set counts
  - Database tables captured

### 2. JSON Report (`test_results.json`)
- Machine-readable format with execution summary
- Includes detailed test results and statistics
- **Full stored procedure output**: Return values, output parameters, all result sets
- **Complete database state**: All captured table data with rows and columns
- Ideal for automated analysis and CI/CD integration

### 3. HTML Report (`test_results.html`)
- Human-readable web page with visual summary
- Color-coded test results (pass/fail/error)
- **Interactive expandable sections** for each test showing:
  - Stored procedure return value
  - Output parameters
  - All result sets with full data
  - Database state for all captured tables
- Collapsible detailed output for easy navigation
- Tables limited to first 10 rows for readability (full data in JSON)

## Examples

See the `Examples/` directory for sample files:
- `test_arguments.csv`: Sample test cases
- `test_data_setup.sql`: Sample database setup
- `cleanup_database.sql`: Sample cleanup script

## Error Handling

The application handles various error scenarios:
- **Database Connection Failures**: Clear error messages with connection details
- **File Not Found**: Specific missing file paths
- **SQL Syntax Errors**: Detailed SQL error information
- **Configuration Errors**: Validation of required settings
- **Test Execution Errors**: Captured and reported per test

## Best Practices

1. **Database Isolation**: Always use cleanup between tests
2. **Meaningful Test Names**: Use descriptive test names and IDs
3. **Comprehensive Coverage**: Include happy path, unhappy path, and edge cases
4. **Dependency Management**: Ensure all test dependencies are in setup scripts
5. **Version Control**: Track test files alongside application code
6. **Regular Execution**: Run tests as part of CI/CD pipeline

## Troubleshooting

### Common Issues

1. **Connection String Problems**
   - Verify server name, database name, and credentials
   - Check network connectivity and SQL Server service status

2. **File Path Issues**
   - Use absolute paths or ensure relative paths are correct
   - Verify file permissions and existence

3. **SQL Syntax Errors**
   - Validate SQL scripts can run independently
   - Check for proper GO statement separation

4. **Test Data Issues**
   - Ensure test data matches stored procedure parameters
   - Verify foreign key relationships in test data

### Debug Mode
Run with `--verbose` flag for detailed execution information:
```bash
dotnet run --verbose
```

This will show:
- SQL commands being executed
- Parameter values being passed
- Detailed error information
- Execution timing for each step